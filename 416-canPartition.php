<?php
class Solution {

    /**
     * https://mp.weixin.qq.com/s/OzdkF30p5BHelCi6inAnNg
     *
     * 分割等和子集
     * 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
    示例 1：
    输入：nums = [1,5,11,5]
    输出：true
    解释：数组可以分割成 [1, 5, 5] 和 [11] 。
     *-----------------------------------------------------------------------
     * 那么对于这个问题，我们可以先对集合求和，得出sum，把问题转化为背包问题：
    给一个可装载重量为sum/2的背包和N个物品，每个物品的重量为nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？
     *
     * dp[i][j] = x表示，对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，
     * 若x为false，则说明不能恰好将背包装满。
     * 比如说，如果dp[4][9] = true，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。
     *
     *
     * base case 就是dp[..][0] = true和dp[0][..] = false，
     * 因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包
     *
     * 状态转移方程
     *      dp[i][j] =
     *
     * @param Integer[] $nums
     * @return Boolean
     */
    function canPartition($nums)
    {
        $sum = array_sum($nums);
        if (($sum % 2) != 0 ) return false;// 奇数，不能凑

        $halfSum = $sum / 2;
        $dp = [];
        $num = count($nums); // 物品数量

        // baseCase
        for ($i = 0; $i <= $num; $i++) {
            $dp[$i][0] = true; // 因为背包没有空间的时候，就相当于装满了
        }
        for ($j = 0; $j <= $sum; $j++) {
            $dp[0][$j] = false; // 而当没有物品可选择的时候，肯定没办法装满背包
        }
        for ($i = 1; $i <= $num; $i++) {
            for ($j = 1; $j <= $sum; $j++) {
                if ($j - $nums[$i-1] < 0) {
                    // 无法装入，只能不装
                    $dp[$i][$j] = $dp[$i-1][$j]; // 取决于前一个
                } else {
                    // 可以装入，选择装或不装
                    $dp[$i][$j] = $dp[$i-1][$j] || $dp[$i-1][$j-$nums[$i-1]]; // 不装入 || 装入情况
                }
            }
        }
        return $dp[$num][$halfSum];
    }

    // 状态压缩：注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，之前的数据都不会再使用了。

}